/**
 * The cache structure Project-Blue uses
 * @typeParam K The type of the {@link Map} keys.
 * @typeParam V The type of the {@link Map} values.
 */
export declare class Cache<K, V> extends Map<K, V> {
    /**
     * The first item in this Cache
     */
    get first(): [K, V] | null;
    /**
     * The first value of this cache
     */
    get firstValue(): V | null;
    /**
     * The first key of this cache
     */
    get firstKey(): K | null;
    /**
     * The last item in this cache
     */
    get last(): [K, V] | null;
    /**
     * The last value of this cache
     */
    get lastValue(): V | null;
    /**
     * The last key of this cache
     */
    get lastKey(): K | null;
    /**
     * Finds an entry from this Cache
     * @param fn Function used to find what you are looking for
     * @param thisArg Optional binding for the fn param
     */
    find(fn: (value: V, key: K, map: this) => boolean, thisArg?: any): [K, V] | undefined;
    /**
     * Finds a key from this Cache
     * @param fn Function used to find what you are looking for
     * @param thisArg Optional binding for the fn param
     */
    findKey(fn: (value: V, key: K, map: this) => boolean, thisArg?: any): K | undefined;
    /**
     * Finds a value from this Cache
     * @param fn Function used to find what you are looking for
     * @param thisArg Optional binding for the fn param
     */
    findValue(fn: (value: V, key: K, map: this) => boolean, thisArg?: any): V | undefined;
    /**
     * Sweeps entries from this Cache
     * @param fn Function used to determine what entries are swept
     * @param thisArg Optional binding for the fn param
     */
    sweep(fn: (value: V, key: K, map: this) => boolean, thisArg?: any): number;
    /**
     * Returns a new filtered Cache based on the filter function
     * @param fn Function used to determine what entries are in the new Cache
     * @param thisArg Optional binding for the fn param
     */
    filter(fn: (value: V, key: K, map: this) => boolean, thisArg?: any): Cache<K, V>;
    /**
     * Maps this Cache to an array (like Array#map())
     * @param fn Function to determine what is mapped to the new Array
     * @param thisArg Optional binding for the fn param
     */
    map<T = any>(fn: (value: V, key: K, map: this) => T, thisArg?: any): T[];
    /**
     * Tests if some entries in this cache meets a condition
     * @param fn The function to test the condition
     * @param thisArg Optional binding for the fn param
     */
    some(fn: (value: V, key: K, map: this) => boolean, thisArg?: any): boolean;
    /**
     * Tests if every entry in this cache meets a condition
     * @param fn The function to test the condition
     * @param thisArg Optional binding for the fn param
     */
    every(fn: (value: V, key: K, map: this) => boolean, thisArg?: any): boolean;
    /**
     * Reduces this cache into a singularity
     * @param fn The function to determine how this Cache is reduced
     * @param initialValue The initial value
     * @param thisArg Optional binding for the fn param
     */
    reduce<I>(fn: (accumulator: I, value: V, key: K, map: this) => I, initialValue: I, thisArg?: any): I;
    /**
     * Returns a shallow clone of this Cache
     */
    clone(): Cache<K, V>;
    /**
     * Returns a new Cache with this and other caches together
     * @param caches Other caches to include in the new cache
     */
    concat(...caches: Cache<K, V>[]): Cache<K, V>;
    /**
     * Naive equality compare function
     * @param cache The cache to compare this against
     */
    equals(cache: Cache<K, V>): boolean;
    /**
     * Sorts entries in-place in this Cache
     * @param compareFunction Function to determine how this Cache should be sorted
     */
    sort(compareFunction?: (v0: V, v1: V, k0?: K, k1?: K) => number): this;
    /**
     * Sorts entries in a new Cache
     * @param compareFunction Function to determine how the resulting Cache should be sorted
     */
    sorted(compareFunction?: (v0: V, v1: V, k0?: K, k1?: K) => number): Cache<K, V>;
}
