import { Cache } from './Cache';
/**
 * The proxy cache structure Project-Blue uses
 * @typeParam K The type of the {@link Map} keys.
 * @typeParam V The type of the {@link Map} values.
 */
export declare class ProxyCache<K, V> implements Map<K, V> {
    #private;
    constructor(store: Map<K, V>, keys?: K[]);
    /**
     * Returns the number of keys in the proxy.
     */
    get size(): number;
    /**
     * Returns the string tag of this proxy object.
     */
    get [Symbol.toStringTag](): string;
    /**
     * Returns a specified element from a Map object. If the value that is associated to the provided key is an object,
     * then you will get a reference to that object and any change made to that object will effectively modify it inside
     * the Map object
     * @param key The key of the element to return from the {@link Map} object.
     * @returns The element associated with the specified key, or `undefined` if the key can't be found in the {@link Map} object.
     */
    get(key: K): V;
    /**
     * Returns a boolean indicating whether an element with the specified key exists or not.
     * @param key The key of the element to test for presence in the proxy and in the {@link Map} object.
     * @returns Whether or not an element with the specified key exists in the proxy and in the {@link Map} object.
     */
    has(key: K): boolean;
    /**
     * Adds a key to the proxy if it wasn't previously added and exists in the {@link Map} object.
     * @param key The key of the element to add to the proxy object.
     * @returns The modified {@link ProxyCache}.
     */
    set(key: K): this;
    /**
     * Removes a key from the proxy.
     * @param key The key of the element to remove from the proxy object.
     * @returns Whether or not the key was removed.
     */
    delete(key: K): boolean;
    /**
     * Removes all keys from the proxy.
     */
    clear(): this;
    /**
     * Executes a provided function once per each key/value pair in the {@link Map} object, in insertion order
     * @param callbackfn Function to execute for each element.
     * @param thisArg Value to use as this when executing callback.
     */
    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: unknown): void;
    /**
     * Returns a new Iterator object that contains the [key, value] pairs for each element in the {@link Map} object
     * contained in the proxy in insertion order.
     */
    [Symbol.iterator](): IterableIterator<[K, V]>;
    /**
     * Returns a new Iterator object that contains the [key, value] pairs for each element in the {@link Map} object
     * contained in the proxy in insertion order.
     */
    entries(): IterableIterator<[K, V]>;
    /**
     * Returns a new Iterator object that contains the keys for each element in the {@link Map} object contained in the
     * proxy in insertion order
     */
    keys(): IterableIterator<K>;
    /**
     * Returns a new Iterator object that contains the values for each element in the {@link Map} object contained in
     * the proxy in insertion order
     */
    values(): IterableIterator<V>;
    static get [Symbol.species](): typeof ProxyCache;
}
export interface ProxyCache<K, V> extends Cache<K, V> {
    clone(): ProxyCache<K, V>;
}
