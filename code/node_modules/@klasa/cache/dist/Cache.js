"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The cache structure Project-Blue uses
 * @typeParam K The type of the {@link Map} keys.
 * @typeParam V The type of the {@link Map} values.
 */
class Cache extends Map {
    /**
     * The first item in this Cache
     */
    get first() {
        return this.size ? this.entries().next().value : null;
    }
    /**
     * The first value of this cache
     */
    get firstValue() {
        return this.size ? this.values().next().value : null;
    }
    /**
     * The first key of this cache
     */
    get firstKey() {
        return this.size ? this.keys().next().value : null;
    }
    /**
     * The last item in this cache
     */
    get last() {
        return this.size ? [...this.entries()][this.size - 1] : null;
    }
    /**
     * The last value of this cache
     */
    get lastValue() {
        return this.size ? [...this.values()][this.size - 1] : null;
    }
    /**
     * The last key of this cache
     */
    get lastKey() {
        return this.size ? [...this.keys()][this.size - 1] : null;
    }
    /**
     * Finds an entry from this Cache
     * @param fn Function used to find what you are looking for
     * @param thisArg Optional binding for the fn param
     */
    find(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        for (const [key, val] of this)
            if (fn(val, key, this))
                return [key, val];
        return undefined;
    }
    /**
     * Finds a key from this Cache
     * @param fn Function used to find what you are looking for
     * @param thisArg Optional binding for the fn param
     */
    findKey(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        for (const [key, val] of this)
            if (fn(val, key, this))
                return key;
        return undefined;
    }
    /**
     * Finds a value from this Cache
     * @param fn Function used to find what you are looking for
     * @param thisArg Optional binding for the fn param
     */
    findValue(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        for (const [key, val] of this)
            if (fn(val, key, this))
                return val;
        return undefined;
    }
    /**
     * Sweeps entries from this Cache
     * @param fn Function used to determine what entries are swept
     * @param thisArg Optional binding for the fn param
     */
    sweep(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        const previousSize = this.size;
        for (const [key, val] of this)
            if (fn(val, key, this))
                this.delete(key);
        return previousSize - this.size;
    }
    /**
     * Returns a new filtered Cache based on the filter function
     * @param fn Function used to determine what entries are in the new Cache
     * @param thisArg Optional binding for the fn param
     */
    filter(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        const results = new this.constructor[Symbol.species]();
        for (const [key, val] of this)
            if (fn(val, key, this))
                results.set(key, val);
        return results;
    }
    /**
     * Maps this Cache to an array (like Array#map())
     * @param fn Function to determine what is mapped to the new Array
     * @param thisArg Optional binding for the fn param
     */
    map(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        const arr = [];
        let i = 0;
        for (const [key, val] of this)
            arr[i++] = fn(val, key, this);
        return arr;
    }
    /**
     * Tests if some entries in this cache meets a condition
     * @param fn The function to test the condition
     * @param thisArg Optional binding for the fn param
     */
    some(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        for (const [key, val] of this)
            if (fn(val, key, this))
                return true;
        return false;
    }
    /**
     * Tests if every entry in this cache meets a condition
     * @param fn The function to test the condition
     * @param thisArg Optional binding for the fn param
     */
    every(fn, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        for (const [key, val] of this)
            if (!fn(val, key, this))
                return false;
        return true;
    }
    /**
     * Reduces this cache into a singularity
     * @param fn The function to determine how this Cache is reduced
     * @param initialValue The initial value
     * @param thisArg Optional binding for the fn param
     */
    reduce(fn, initialValue, thisArg) {
        if (typeof thisArg !== 'undefined')
            fn = fn.bind(thisArg);
        let accumulator = initialValue;
        for (const [key, val] of this)
            accumulator = fn(accumulator, val, key, this);
        return accumulator;
    }
    /**
     * Returns a shallow clone of this Cache
     */
    clone() {
        return new this.constructor[Symbol.species](this);
    }
    /**
     * Returns a new Cache with this and other caches together
     * @param caches Other caches to include in the new cache
     */
    concat(...caches) {
        const newColl = this.clone();
        for (const coll of caches)
            for (const [key, val] of coll)
                newColl.set(key, val);
        return newColl;
    }
    /**
     * Naive equality compare function
     * @param cache The cache to compare this against
     */
    equals(cache) {
        return this === cache || (this.size === cache.size && this.every((value, key) => cache.get(key) === value));
    }
    /**
     * Sorts entries in-place in this Cache
     * @param compareFunction Function to determine how this Cache should be sorted
     */
    sort(compareFunction = (first, second) => +(first > second) || +(first === second) - 1) {
        const entries = [...this.entries()]
            .sort((e0, e1) => compareFunction(e0[1], e1[1], e0[0], e1[0]));
        this.clear();
        for (const [key, value] of entries)
            this.set(key, value);
        return this;
    }
    /**
     * Sorts entries in a new Cache
     * @param compareFunction Function to determine how the resulting Cache should be sorted
     */
    sorted(compareFunction = (first, second) => +(first > second) || +(first === second) - 1) {
        const entries = [...this.entries()]
            .sort((e0, e1) => compareFunction(e0[1], e1[1], e0[0], e1[0]));
        return new this.constructor(entries);
    }
}
exports.Cache = Cache;
//# sourceMappingURL=Cache.js.map