"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.In17nHandler = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/naming-convention */
const framework_1 = require("@sapphire/framework");
const RootDir_1 = require("@sapphire/framework/dist/lib/utils/RootDir");
const utilities_1 = require("@sapphire/utilities");
const discord_js_1 = require("discord.js");
const fs_1 = require("fs");
const i18next_1 = tslib_1.__importDefault(require("i18next"));
const i18next_fs_backend_1 = tslib_1.__importDefault(require("i18next-fs-backend"));
const path_1 = require("path");
class In17nHandler {
    constructor(client) {
        var _a, _b, _c;
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: client
        });
        /**
         * Describes whether `In17nHandler#init` has been run and languages are loaded in `In17nHandler.languages`.
         * @since 1.0.0
         */
        Object.defineProperty(this, "languagesLoaded", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * A `Collection` of "i18next" language functions keyed by their language code.
         * @since 1.0.0
         */
        Object.defineProperty(this, "languages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "languagesDir", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "backendOptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.languagesDir = (_b = (_a = this.client.options.i18n) === null || _a === void 0 ? void 0 : _a.defaultLanguageDirectory) !== null && _b !== void 0 ? _b : path_1.join(RootDir_1.getRootDirectory(), 'languages');
        this.backendOptions = utilities_1.mergeDefault({
            loadPath: path_1.join(this.languagesDir, '{{lng}}', '{{ns}}.json'),
            addPath: this.languagesDir
        }, (_c = this.client.options.i18n) === null || _c === void 0 ? void 0 : _c.backend);
    }
    async init() {
        var _a, _b, _c, _d, _e;
        const { namespaces, languages } = await this.walkLanguageDirectory(this.languagesDir);
        i18next_1.default.use(i18next_fs_backend_1.default);
        await i18next_1.default.init(utilities_1.mergeDefault({
            backend: this.backendOptions,
            fallbackLng: (_b = (_a = this.client.options.i18n) === null || _a === void 0 ? void 0 : _a.defaultName) !== null && _b !== void 0 ? _b : 'en-US',
            initImmediate: false,
            interpolation: {
                escapeValue: false
            },
            load: 'all',
            defaultNS: (_d = (_c = this.client.options.i18n) === null || _c === void 0 ? void 0 : _c.defaultNS) !== null && _d !== void 0 ? _d : 'default',
            ns: namespaces,
            preload: languages
        }, (_e = this.client.options.i18n) === null || _e === void 0 ? void 0 : _e.i18next));
        this.languages = new discord_js_1.Collection(languages.map(item => [item, i18next_1.default.getFixedT(item)]));
        this.languagesLoaded = true;
    }
    /**
     * Resolves the language from the message. The resolution order is at follows:
     * client.fetchLanguage -> message.guild.preferredLocale -> this.client.options.i18n.defaultName -> 'en-US'
     * @param message The message from which the language should be resolved.
     * @since 1.0.0
     */
    async resolveNameFromMessage(message) {
        var _a, _b, _c, _d;
        const lang = await this.client.fetchLanguage(message);
        return (_d = (_b = lang !== null && lang !== void 0 ? lang : (_a = message.guild) === null || _a === void 0 ? void 0 : _a.preferredLocale) !== null && _b !== void 0 ? _b : (_c = this.client.options.i18n) === null || _c === void 0 ? void 0 : _c.defaultName) !== null && _d !== void 0 ? _d : 'en-US';
    }
    /**
     * Resolves a localised string from a language, key, optional replaceables, and optional i18next options.
     * @param name The language to be used.
     * @param key The key that should be translated.
     * @param replace The replaceable keys in translation string.
     * @param options i18next language options.
     * @since 1.0.0
     */
    resolveValue(name, key, replace, options) {
        var _a, _b;
        if (!this.languagesLoaded)
            throw new framework_1.UserError('In17nLanguagesNotLoaded', 'Cannot call this method until In17nHandler#init has been called');
        const language = this.languages.get(name);
        if (!language)
            throw new framework_1.UserError('In17nLanguageNotFound', 'Invalid language provided');
        return language(key, utilities_1.mergeDefault({
            defaultValue: language((_b = (_a = this.client.options.i18n) === null || _a === void 0 ? void 0 : _a.defaultMissingKey) !== null && _b !== void 0 ? _b : 'default:default', { replace: { key } }),
            replace
        }, options));
    }
    async walkLanguageDirectory(dir, namespaces = [], folderName = '') {
        const files = await fs_1.promises.readdir(dir);
        const languages = [];
        for (const file of files) {
            const stat = await fs_1.promises.stat(path_1.join(dir, file));
            if (stat.isDirectory()) {
                const isLanguage = file.includes('-');
                if (isLanguage)
                    languages.push(file);
                ({ namespaces } = await this.walkLanguageDirectory(path_1.join(dir, file), namespaces, isLanguage ? '' : `${file}/`));
            }
            else {
                namespaces.push(`${folderName}${file.substr(0, file.length - 5)}`);
            }
        }
        return { namespaces: [...new Set(namespaces)], languages };
    }
}
exports.In17nHandler = In17nHandler;
//# sourceMappingURL=In17nHandler.js.map